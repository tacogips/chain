// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: erd.proto

package gen

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Order int32

const (
	Order_ASC  Order = 0
	Order_DESC Order = 1
)

var Order_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var Order_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x Order) String() string {
	return proto.EnumName(Order_name, int32(x))
}
func (Order) EnumDescriptor() ([]byte, []int) { return fileDescriptorErd, []int{0} }

type Coordinate struct {
	X float32 `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y float32 `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Coordinate) Reset()                    { *m = Coordinate{} }
func (m *Coordinate) String() string            { return proto.CompactTextString(m) }
func (*Coordinate) ProtoMessage()               {}
func (*Coordinate) Descriptor() ([]byte, []int) { return fileDescriptorErd, []int{0} }

type Size struct {
	Width  float32 `protobuf:"fixed32,1,opt,name=width,proto3" json:"width,omitempty"`
	Height float32 `protobuf:"fixed32,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *Size) Reset()                    { *m = Size{} }
func (m *Size) String() string            { return proto.CompactTextString(m) }
func (*Size) ProtoMessage()               {}
func (*Size) Descriptor() ([]byte, []int) { return fileDescriptorErd, []int{1} }

type Activity struct {
	Id float32 `protobuf:"fixed32,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Activity) Reset()                    { *m = Activity{} }
func (m *Activity) String() string            { return proto.CompactTextString(m) }
func (*Activity) ProtoMessage()               {}
func (*Activity) Descriptor() ([]byte, []int) { return fileDescriptorErd, []int{2} }

type ShowActivityFilter struct {
	Number     int32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	SkipNumber int32 `protobuf:"varint,2,opt,name=skip_number,json=skipNumber,proto3" json:"skip_number,omitempty"`
	Order      Order `protobuf:"varint,3,opt,name=order,proto3,enum=erd.Order" json:"order,omitempty"`
}

func (m *ShowActivityFilter) Reset()                    { *m = ShowActivityFilter{} }
func (m *ShowActivityFilter) String() string            { return proto.CompactTextString(m) }
func (*ShowActivityFilter) ProtoMessage()               {}
func (*ShowActivityFilter) Descriptor() ([]byte, []int) { return fileDescriptorErd, []int{3} }

type ObjectID struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Val  string `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
}

func (m *ObjectID) Reset()                    { *m = ObjectID{} }
func (m *ObjectID) String() string            { return proto.CompactTextString(m) }
func (*ObjectID) ProtoMessage()               {}
func (*ObjectID) Descriptor() ([]byte, []int) { return fileDescriptorErd, []int{4} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorErd, []int{5} }

func init() {
	proto.RegisterType((*Coordinate)(nil), "erd.Coordinate")
	proto.RegisterType((*Size)(nil), "erd.Size")
	proto.RegisterType((*Activity)(nil), "erd.Activity")
	proto.RegisterType((*ShowActivityFilter)(nil), "erd.showActivityFilter")
	proto.RegisterType((*ObjectID)(nil), "erd.ObjectID")
	proto.RegisterType((*Empty)(nil), "erd.Empty")
	proto.RegisterEnum("erd.Order", Order_name, Order_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ActivityService service

type ActivityServiceClient interface {
	Find(ctx context.Context, in *Empty, opts ...grpc.CallOption) (ActivityService_FindClient, error)
}

type activityServiceClient struct {
	cc *grpc.ClientConn
}

func NewActivityServiceClient(cc *grpc.ClientConn) ActivityServiceClient {
	return &activityServiceClient{cc}
}

func (c *activityServiceClient) Find(ctx context.Context, in *Empty, opts ...grpc.CallOption) (ActivityService_FindClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ActivityService_serviceDesc.Streams[0], c.cc, "/erd.ActivityService/find", opts...)
	if err != nil {
		return nil, err
	}
	x := &activityServiceFindClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ActivityService_FindClient interface {
	Recv() (*Activity, error)
	grpc.ClientStream
}

type activityServiceFindClient struct {
	grpc.ClientStream
}

func (x *activityServiceFindClient) Recv() (*Activity, error) {
	m := new(Activity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ActivityService service

type ActivityServiceServer interface {
	Find(*Empty, ActivityService_FindServer) error
}

func RegisterActivityServiceServer(s *grpc.Server, srv ActivityServiceServer) {
	s.RegisterService(&_ActivityService_serviceDesc, srv)
}

func _ActivityService_Find_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ActivityServiceServer).Find(m, &activityServiceFindServer{stream})
}

type ActivityService_FindServer interface {
	Send(*Activity) error
	grpc.ServerStream
}

type activityServiceFindServer struct {
	grpc.ServerStream
}

func (x *activityServiceFindServer) Send(m *Activity) error {
	return x.ServerStream.SendMsg(m)
}

var _ActivityService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "erd.ActivityService",
	HandlerType: (*ActivityServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "find",
			Handler:       _ActivityService_Find_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "erd.proto",
}

func (m *Coordinate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coordinate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Erd(dAtA, i, uint32(math.Float32bits(float32(m.X))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Erd(dAtA, i, uint32(math.Float32bits(float32(m.Y))))
	}
	return i, nil
}

func (m *Size) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Size) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Erd(dAtA, i, uint32(math.Float32bits(float32(m.Width))))
	}
	if m.Height != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Erd(dAtA, i, uint32(math.Float32bits(float32(m.Height))))
	}
	return i, nil
}

func (m *Activity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Activity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Erd(dAtA, i, uint32(math.Float32bits(float32(m.Id))))
	}
	return i, nil
}

func (m *ShowActivityFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowActivityFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintErd(dAtA, i, uint64(m.Number))
	}
	if m.SkipNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintErd(dAtA, i, uint64(m.SkipNumber))
	}
	if m.Order != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintErd(dAtA, i, uint64(m.Order))
	}
	return i, nil
}

func (m *ObjectID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErd(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Val) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErd(dAtA, i, uint64(len(m.Val)))
		i += copy(dAtA[i:], m.Val)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Erd(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Erd(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintErd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Coordinate) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	return n
}

func (m *Size) Size() (n int) {
	var l int
	_ = l
	if m.Width != 0 {
		n += 5
	}
	if m.Height != 0 {
		n += 5
	}
	return n
}

func (m *Activity) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 5
	}
	return n
}

func (m *ShowActivityFilter) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovErd(uint64(m.Number))
	}
	if m.SkipNumber != 0 {
		n += 1 + sovErd(uint64(m.SkipNumber))
	}
	if m.Order != 0 {
		n += 1 + sovErd(uint64(m.Order))
	}
	return n
}

func (m *ObjectID) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovErd(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovErd(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovErd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozErd(x uint64) (n int) {
	return sovErd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Coordinate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Y = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipErd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Size) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Size: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Size: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Width = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Height = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipErd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Activity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Activity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Activity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Id = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipErd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowActivityFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: showActivityFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: showActivityFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipNumber", wireType)
			}
			m.SkipNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (Order(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipErd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowErd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthErd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowErd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipErd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthErd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowErd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("erd.proto", fileDescriptorErd) }

var fileDescriptorErd = []byte{
	// 379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x91, 0xcd, 0x6e, 0xda, 0x40,
	0x14, 0x85, 0x19, 0xff, 0xf0, 0x73, 0xdb, 0x52, 0x34, 0x6a, 0x2b, 0xe4, 0x85, 0x41, 0xee, 0x06,
	0x55, 0x2a, 0x20, 0x5a, 0x65, 0x4f, 0x80, 0x48, 0xd9, 0x04, 0xc9, 0xde, 0x65, 0x13, 0xd9, 0x9e,
	0xc1, 0x9e, 0x04, 0x7b, 0xac, 0x61, 0x0c, 0x38, 0x4f, 0xc8, 0x32, 0x8f, 0x90, 0xf0, 0x24, 0x91,
	0xc7, 0x46, 0x91, 0xb2, 0x3b, 0xe7, 0x7e, 0xe7, 0x1e, 0x7b, 0x66, 0xa0, 0x43, 0x05, 0x19, 0x67,
	0x82, 0x4b, 0x8e, 0x75, 0x2a, 0x88, 0xf5, 0x37, 0x62, 0x32, 0xce, 0x83, 0x71, 0xc8, 0x93, 0x49,
	0xc4, 0x23, 0x3e, 0x51, 0x2c, 0xc8, 0x37, 0xca, 0x29, 0xa3, 0x54, 0xb5, 0x63, 0xd9, 0x11, 0xe7,
	0xd1, 0x96, 0x7e, 0xa4, 0x48, 0x2e, 0x7c, 0xc9, 0x78, 0x5a, 0xf3, 0xc1, 0x67, 0x2e, 0x59, 0x42,
	0x77, 0xd2, 0x4f, 0xb2, 0x2a, 0xe0, 0x8c, 0x00, 0x16, 0x9c, 0x0b, 0xc2, 0x52, 0x5f, 0x52, 0xfc,
	0x15, 0xd0, 0xb1, 0x8f, 0x86, 0x68, 0xa4, 0xb9, 0xe8, 0x58, 0xba, 0xa2, 0xaf, 0x55, 0xae, 0x70,
	0xfe, 0x83, 0xe1, 0xb1, 0x67, 0x8a, 0x7f, 0x80, 0x79, 0x60, 0x44, 0xc6, 0x75, 0xae, 0x32, 0xf8,
	0x17, 0x34, 0x63, 0xca, 0xa2, 0x58, 0xd6, 0x0b, 0xb5, 0x73, 0x2c, 0x68, 0xcf, 0x43, 0xc9, 0xf6,
	0x4c, 0x16, 0xb8, 0x0b, 0x1a, 0x23, 0xf5, 0x9a, 0xc6, 0x88, 0xc3, 0x01, 0xef, 0x62, 0x7e, 0xb8,
	0xf0, 0x1b, 0xb6, 0x95, 0x54, 0x94, 0x4d, 0x69, 0x9e, 0x04, 0x54, 0xa8, 0xa4, 0xe9, 0xd6, 0x0e,
	0x0f, 0xe0, 0xcb, 0xee, 0x89, 0x65, 0x0f, 0x35, 0xd4, 0x14, 0x84, 0x72, 0x74, 0x57, 0x05, 0x86,
	0x60, 0x72, 0x41, 0xa8, 0xe8, 0xeb, 0x43, 0x34, 0xea, 0xce, 0x60, 0x5c, 0x5e, 0xed, 0xba, 0x9c,
	0xb8, 0x15, 0x70, 0xa6, 0xd0, 0x5e, 0x07, 0x8f, 0x34, 0x94, 0xb7, 0x4b, 0x8c, 0xc1, 0x90, 0x45,
	0x46, 0xd5, 0x47, 0x3a, 0xae, 0xd2, 0xb8, 0x07, 0xfa, 0xde, 0xdf, 0xaa, 0xea, 0x8e, 0x5b, 0x4a,
	0xa7, 0x05, 0xe6, 0x2a, 0xc9, 0x64, 0xf1, 0xc7, 0x02, 0x53, 0x55, 0xe1, 0x16, 0xe8, 0x73, 0x6f,
	0xd1, 0x6b, 0xe0, 0x36, 0x18, 0xcb, 0x95, 0xb7, 0xe8, 0xa1, 0xd9, 0x15, 0x7c, 0xbf, 0x9c, 0xc1,
	0xa3, 0x62, 0xcf, 0x42, 0x8a, 0x7f, 0x83, 0xb1, 0x61, 0x29, 0xc1, 0xd5, 0x4f, 0xa8, 0x0a, 0xeb,
	0x9b, 0xd2, 0x97, 0xe4, 0x14, 0x5d, 0xff, 0x3c, 0xbd, 0xd9, 0x8d, 0xd3, 0xd9, 0x46, 0x2f, 0x67,
	0x1b, 0xbd, 0x9e, 0x6d, 0x74, 0xaf, 0x47, 0x34, 0x0d, 0x9a, 0xea, 0x65, 0xfe, 0xbd, 0x07, 0x00,
	0x00, 0xff, 0xff, 0x9b, 0x41, 0xa9, 0x35, 0x1b, 0x02, 0x00, 0x00,
}
